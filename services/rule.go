package services

import (
	"bufio"
	"bytes"
	"fmt"
	"io/ioutil"
	"strings"

	"github.com/ugorji/go/codec"

	"github.com/OperatorFoundation/AdversaryLab/storage"
	"github.com/OperatorFoundation/AdversaryLab/protocol"
)

type RuleHandlers struct {
	handlers   map[string]*RuleHandler	// key (i.e. "Dataset1-incoming") to value (rule handler for "dataset1-incoming")
	source     protocol.PubsubSource	// channel to be used for sending out updates as bytes
	storeCache *storage.StoreCache		// updated cache that maps "dataset1-incoming" to store containing the offset/subsequence rule candidates
}

type RuleHandler struct {
	path       string			// i.e. "dataset1-incoming"
	store      *storage.Store		// store containing the offset/subsequence rule candidates
	cachedRule *storage.RuleCandidate	// initially set to nil
}

type RuleService struct {
	handlers RuleHandlers
	serve    protocol.PubsubServer		// contains socket for sending out rules as bytes from PubsubSource
	updates  chan Update			// contains the "dataset1-incoming"+best rule candidate updates; is incoming
	source   protocol.PubsubSource		// channel to be used for sending out updates as bytes
}

// listenAddress is tcp://localhost:4568. updates contains the "dataset1-incoming"+best rule candidate updates
// that should be sent out. Add the offsets-sequence store to the storeCache.
func NewRuleService(listenAddress string, updates chan Update, storeCache *storage.StoreCache) *RuleService {
	// PubsubSource is just a byte channel that will be used to send out the updates to subscribers.
	source := make(protocol.PubsubSource)

	handlers := RuleHandlers{handlers: make(map[string]*RuleHandler), source: source, storeCache: storeCache}
	files, err := ioutil.ReadDir("store")
	if err != nil {
		fmt.Println("Failed to read store directory", err)
	} else {
		// For all of the files in the store directory ("dataset1-incoming",
		// "dataset1-incoming-offsets-sequence", 'dataset1-outgoing",
		// "dataset1-outgoing-offsets-sequence")
		for _, file := range files {
			handlers.Load(file.Name())
		}
	}

	serve := protocol.PubsubListen(listenAddress, source)

	return &RuleService{handlers: handlers, serve: serve, updates: updates, source: source}
}

// go routine started from main server.  Retrieves rule updates from the socket and
func (self *RuleService) Run() {
	go self.handleUpdates()
	self.serve.Pump()
}

// Update the storecache so the keys (i.e. "dataset1-incoming") map to the store that recorded
// the offset/subsequence combinations.
func (self RuleHandlers) Load(name string) *RuleHandler {
	var store *storage.Store
	var err error

	if handler, ok := self.handlers[name]; ok {
		return handler
	} else {
		// Add the files (index and source) that record the offset/subsequence combinations
		// to the storeCache.
		// Behavior isn't quite correct here, as there will be undesired
		// "dataset1-incoming-offsets-sequence-offsets-sequence" stores created.
		store = self.storeCache.Get(name + "-offsets-sequence")
		if store == nil {
			store, err = storage.OpenStore(name + "-offsets-sequence")
			if err != nil {
				fmt.Println("Error opening store")
				fmt.Println(err)
				return nil
			}

			// This overrides the stores.
			// Now "dataset1-incoming"->the store containing the rule candidates
			// Now "dataset1-incoming-offsets-sequence"->a store containing nothing
			self.storeCache.Put(name, store)
		}

		//		fmt.Println("New rule store", store)
		// path is "dataset1-incoming", the store contains the rule candidates now rather than the
		// original training packet payloads.
		handler := &RuleHandler{path: name, store: store, cachedRule: nil}
		self.handlers[name] = handler

		return handler
	}
}

// Put the rule to send on the PubsubSource channel by converting it to bytes.
func sendRule(source protocol.PubsubSource, rule *protocol.Rule) {
	var value = protocol.NamedType{Name: "protocol.Rule", Value: rule}

	var buff = new(bytes.Buffer)
	var bw = bufio.NewWriter(buff)
	var h codec.Handle = protocol.NamedTypeHandle()

	var enc *codec.Encoder = codec.NewEncoder(bw, h)
	var err error = enc.Encode(value)
	if err != nil {
		fmt.Printf("Error encoding packet: %s", err.Error())
		return
	}

	bw.Flush()

	source <- buff.Bytes()
}

// go routine that reads from the incoming best rule candidate update channel.
func (self *RuleService) handleUpdates() {
	// iterate through the incoming best rule candidate updates that are generated by
	// processing training packets.
	for update := range self.updates {
		//		fmt.Println("received update", update)
		name := update.Path 		// i.e. "dataset1-incoming"
		handler := self.handlers.Load(name)
		if handler != nil {
			result := handler.Handle(name, update.Rule)
			if result != nil {
				fmt.Println("Sending rule", name, len(result.Sequence), result)
				fmt.Print("!")
				sendRule(self.source, result)
			}
		} else {
			fmt.Println("Could not load handler for", name)
		}
	}
}

// Process a best rule candidate from the updates channel. name is something like "dataset1-incoming".
// Get a Rule struct that packages the rule slightly differently.
func (self *RuleHandler) Handle(name string, cn *storage.RuleCandidate) *protocol.Rule {
	self.cachedRule = cn
	index := cn.Index
	//	fmt.Println("Handle", self.store)
	storage.Debug = true
	// Gets the offset/subsequence combination for the index provided in the rule candidate.
	record, err := self.store.GetRecord(index)
	storage.Debug = false
	if err != nil {
		return nil
	}

	fmt.Println("Rule record:", record)

	sequence := record.Data			// the sequence is really the offset and byte subsequence concatenated
	parts := strings.Split(name, "-")	// get just ["dataset1", "incoming"]

	return &protocol.Rule{Dataset: parts[0], RequireForbid: cn.RequireForbid(), Incoming: parts[1] == "incoming", Sequence: sequence}
}
